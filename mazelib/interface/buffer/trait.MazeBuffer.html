<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A maze cell container."><title>MazeBuffer in mazelib::interface::buffer - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ae1b282cda4c21ec.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mazelib" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (20999de3a 2023-09-15)" data-channel="nightly" data-search-js="search-5d3eaacf19ebf04f.js" data-settings-js="settings-74424d7eec62a23e.js" data-theme-light-css="light-f194925aa375ae96.css" data-theme-dark-css="dark-1dd4d1ce031e15de.css" data-theme-ayu-css="ayu-49e58d069f567085.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-cabe4b1bd7b9da95.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-f194925aa375ae96.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1dd4d1ce031e15de.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="stylesheet" href="../../../theme.css"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../mazelib/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../mazelib/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">MazeBuffer</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.get">get</a></li><li><a href="#tymethod.get_mut">get_mut</a></li><li><a href="#tymethod.new">new</a></li><li><a href="#tymethod.set">set</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In mazelib::interface::buffer</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../../index.html">mazelib</a>::<wbr><a href="../index.html">interface</a>::<wbr><a href="index.html">buffer</a>::<wbr><a class="trait" href="#">MazeBuffer</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/mazelib/interface/buffer.rs.html#31-142">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait MazeBuffer&lt;CellVal: <a class="trait" href="../cell/trait.CellValue.html" title="trait mazelib::interface::cell::CellValue">CellValue</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> {
    // Required methods
    fn <a href="#tymethod.new" class="fn">new</a>(cell_count: <a class="struct" href="https://doc.rust-lang.org/nightly/core/num/nonzero/struct.NonZeroUsize.html" title="struct core::num::nonzero::NonZeroUsize">NonZeroUsize</a>) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.get" class="fn">get</a>(&amp;self, cell: <a class="struct" href="../cell/struct.CellID.html" title="struct mazelib::interface::cell::CellID">CellID</a>) -&gt; CellVal;
<span class="item-spacer"></span>    fn <a href="#tymethod.get_mut" class="fn">get_mut</a>(&amp;mut self, cell: <a class="struct" href="../cell/struct.CellID.html" title="struct mazelib::interface::cell::CellID">CellID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut CellVal</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.set" class="fn">set</a>(&amp;mut self, cell: <a class="struct" href="../cell/struct.CellID.html" title="struct mazelib::interface::cell::CellID">CellID</a>, new_value: CellVal);
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A maze cell container.</p>
<p>Maze buffers store the values of all cells in a maze. This is the meat of the maze. They
are not responsible for other <a href="../index.html#core-components" title="mod mazelib::interface">core maze components</a>.
These are maintained by the <a href="../coordinate/trait.MazeCoordinator.html" title="trait mazelib::interface::coordinate::MazeCoordinator">maze coordinator</a>
(which also holds a maze’s buffer).</p>
<p>A buffer’s size is determined at construction and cannot be changed.</p>
<p>Buffers are very low-level and not intended to be interacted with directly. They should
always be accessed through the maze coordinator. Likewise, they should not be constructed
directly. The maze coordinator is responsible for the construction of the buffer.</p>
<p>While most buffers would store their contents in memory, it is conceivable that a buffer
could stream the maze from disk (or elsewhere). This would allow mazes too large to fit in
memory to be generated.</p>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.new" class="method"><a class="src rightside" href="../../../src/mazelib/interface/buffer.rs.html#59">source</a><h4 class="code-header">fn <a href="#tymethod.new" class="fn">new</a>(cell_count: <a class="struct" href="https://doc.rust-lang.org/nightly/core/num/nonzero/struct.NonZeroUsize.html" title="struct core::num::nonzero::NonZeroUsize">NonZeroUsize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Construct a new buffer.</p>
<p>As discussed in the type documentation, typically you wouldn’t invoke this function
directly. Normally you’d use a <a href="trait.MazeBuffer.html" title="trait mazelib::interface::buffer::MazeBuffer"><code>MazeBuffer</code></a> which would abstract away interacting with
the buffer from you.</p>
<h5 id="parameters"><a href="#parameters">Parameters</a></h5>
<p><code>cell_count</code> — the size of the maze’s cell space, and the number of cells that the
buffer is required to track. If the buffer differentiates between size
and capacity, this must be be less than its capacity. The size cannot
be changed once a buffer is constructed. As a maze must always have at
least one point, and every point maps to at least one cell, all mazes
must have at least one cell, hence <code>cell_count</code> is a <code>NonZeroUsize</code>.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>coord_space = BoxCoordinateSpace::new_checked([<span class="number">3</span>, <span class="number">3</span>]);

<span class="kw">let </span>buffer = VecBuffer::&lt;BlockCellValue&gt;::new(coord_space.logical_size());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get" class="method"><a class="src rightside" href="../../../src/mazelib/interface/buffer.rs.html#80">source</a><h4 class="code-header">fn <a href="#tymethod.get" class="fn">get</a>(&amp;self, cell: <a class="struct" href="../cell/struct.CellID.html" title="struct mazelib::interface::cell::CellID">CellID</a>) -&gt; CellVal</h4></section></summary><div class="docblock"><p>Get the value of a given cell.</p>
<h5 id="parameters-1"><a href="#parameters-1">Parameters</a></h5>
<p><code>cell</code> — the ID of the cell to retrieve. Must be inbounds (&lt;= this buffer’s size).</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Make a new buffer
</span><span class="kw">let </span>buffer = VecBuffer::&lt;BlockCellValue&gt;::new(NonZeroUsize::new(<span class="number">1</span>).expect(<span class="string">&quot;If this fails the sky is falling&quot;</span>));

<span class="macro">assert_eq!</span>(BlockCellValue::default(), buffer.get(CellID(<span class="number">0</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.get_mut" class="method"><a class="src rightside" href="../../../src/mazelib/interface/buffer.rs.html#113">source</a><h4 class="code-header">fn <a href="#tymethod.get_mut" class="fn">get_mut</a>(&amp;mut self, cell: <a class="struct" href="../cell/struct.CellID.html" title="struct mazelib::interface::cell::CellID">CellID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut CellVal</a></h4></section></summary><div class="docblock"><p>Get the value of a given cell for mutation.</p>
<p>Useful for modifying parts of a cell while leaving the rest of it untouched. If you wish
to change the value of a cell in its entirety, consider <a href="trait.MazeBuffer.html#tymethod.set"><code>set()</code></a>.</p>
<h5 id="parameters-2"><a href="#parameters-2">Parameters</a></h5>
<p><code>cell</code> — the ID of the cell to retrieve. Must be inbounds (≤ this buffer’s size).</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Make a new buffer
</span><span class="kw">let </span><span class="kw-2">mut </span>buffer = VecBuffer::&lt;BlockCellValue&gt;::new(NonZeroUsize::new(<span class="number">1</span>).expect(<span class="string">&quot;If this fails the sky is falling&quot;</span>));

<span class="kw">let </span>cell_id = CellID(<span class="number">0</span>);
<span class="kw">let </span>cell = BlockCellValue { cell_type: BlockCellPrimaryValue::PASSAGE, marked: <span class="bool-val">false </span>};

buffer.set(cell_id, cell);

<span class="macro">assert!</span>(buffer.get(cell_id).marked == <span class="bool-val">false</span>);

buffer.get_mut(cell_id).marked = <span class="bool-val">true</span>;

<span class="macro">assert!</span>(buffer.get(cell_id).marked);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.set" class="method"><a class="src rightside" href="../../../src/mazelib/interface/buffer.rs.html#141">source</a><h4 class="code-header">fn <a href="#tymethod.set" class="fn">set</a>(&amp;mut self, cell: <a class="struct" href="../cell/struct.CellID.html" title="struct mazelib::interface::cell::CellID">CellID</a>, new_value: CellVal)</h4></section></summary><div class="docblock"><p>Set the value of a given cell.</p>
<p>If you wish to modify only part of a cell while leaving the rest of it untouched,
consider <a href="trait.MazeBuffer.html#tymethod.get_mut"><code>get_mut()</code></a>.</p>
<h5 id="parameters-3"><a href="#parameters-3">Parameters</a></h5>
<p><code>cell</code> — the ID of the cell to modify. Must be inbounds (≤ this buffer’s size).</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Make a new buffer
</span><span class="kw">let </span><span class="kw-2">mut </span>buffer = VecBuffer::&lt;BlockCellValue&gt;::new(NonZeroUsize::new(<span class="number">1</span>).expect(<span class="string">&quot;If this fails the sky is falling&quot;</span>));

<span class="kw">let </span>cell_id = CellID(<span class="number">0</span>);
<span class="kw">let </span>cell = BlockCellValue { cell_type: BlockCellPrimaryValue::PASSAGE, marked: <span class="bool-val">false </span>};

buffer.set(cell_id, cell);

<span class="macro">assert_eq!</span>(cell, buffer.get(cell_id));</code></pre></div>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-MazeBuffer%3CCellVal%3E-for-VecBuffer%3CCellVal%3E" class="impl"><a class="src rightside" href="../../../src/mazelib/implm/buffer/vec.rs.html#14-30">source</a><a href="#impl-MazeBuffer%3CCellVal%3E-for-VecBuffer%3CCellVal%3E" class="anchor">§</a><h3 class="code-header">impl&lt;CellVal: <a class="trait" href="../cell/trait.CellValue.html" title="trait mazelib::interface::cell::CellValue">CellValue</a>&gt; <a class="trait" href="trait.MazeBuffer.html" title="trait mazelib::interface::buffer::MazeBuffer">MazeBuffer</a>&lt;CellVal&gt; for <a class="struct" href="../../implm/buffer/struct.VecBuffer.html" title="struct mazelib::implm::buffer::VecBuffer">VecBuffer</a>&lt;CellVal&gt;</h3></section><section id="impl-MazeBuffer%3CCellVal%3E-for-ArrayBuffer%3CCellVal,+CELLS%3E" class="impl"><a class="src rightside" href="../../../src/mazelib/implm/buffer/array.rs.html#20-50">source</a><a href="#impl-MazeBuffer%3CCellVal%3E-for-ArrayBuffer%3CCellVal,+CELLS%3E" class="anchor">§</a><h3 class="code-header">impl&lt;CellVal: <a class="trait" href="../cell/trait.CellValue.html" title="trait mazelib::interface::cell::CellValue">CellValue</a>, const CELLS: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="trait.MazeBuffer.html" title="trait mazelib::interface::buffer::MazeBuffer">MazeBuffer</a>&lt;CellVal&gt; for <a class="struct" href="../../implm/buffer/struct.ArrayBuffer.html" title="struct mazelib::implm::buffer::ArrayBuffer">ArrayBuffer</a>&lt;CellVal, CELLS&gt;</h3></section></div><script src="../../../implementors/mazelib/interface/buffer/trait.MazeBuffer.js" async></script></section></div></main></body></html>